"""
Unittest framework for intro CS course. This provides extremely easy to read error messages for the
failures and errors generated by the unittest framework included with Python.

It also adds a few other features including having a timeout on the execution of code.
"""

import os.path
import warnings
import signal
import unittest
import sys
import re
import io
import contextlib
import itertools
import ast
import builtins
import types
import difflib

from ._testcase_assert_mod import wrap_test_case_asserts

class Timeout(RuntimeError):
    """Exception raised when a timeout occurs."""

class timeout: # pylint: disable=invalid-name
    """
    Context manager that raises a Timeout exception if the context (i.e. with statement) is not
    exited before the timeout occurs. If the Timeout is caught but the context is not exited, it
    will be continually be generated again every timeout iteration.
    """
    def __init__(self, seconds):
        self.seconds = seconds

    def __handle_timeout(self, signum, frame):
        """Called when a timeout occurs"""
        raise Timeout(f'test timed out after {self.seconds}s.')

    def __enter__(self):
        """Turns on the alarm timer which will call __handle_timeout"""
        signal.signal(signal.SIGALRM, self.__handle_timeout)
        signal.setitimer(signal.ITIMER_REAL, self.seconds, self.seconds)

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Turns off the alarm timer"""
        signal.setitimer(signal.ITIMER_REAL, 0, self.seconds)

def _get_line_of_code(filename, line_num):
    # TODO: any wrapped lines of code need to be treated
    with open(filename, 'r') as file:
        return file.readlines()[line_num-1]

def _get_verbose_code_from_tb(traceback, desc='The test'):
    filename = traceback.tb_frame.f_code.co_filename
    line_num = traceback.tb_lineno
    func_name = traceback.tb_frame.f_code.co_name
    return f'{desc} was in {os.path.basename(filename)} on line {line_num} in {func_name}()\n' + \
        _get_line_of_code(filename, line_num).strip() # TODO: deal with multi-line code

def _skip_unittest_frames(traceback):
    while traceback is not None and '__unittest' in traceback.tb_frame.f_globals:
        traceback = traceback.tb_next
    return traceback

def _print_import_error(ex):
    msg = str(ex).splitlines()
    if msg[-1].startswith("SyntaxError") or msg[-1].startswith("IndentationError"):
        err = 'a syntax' if msg[-1].startswith("SyntaxError") else 'an indentation'
        filename, line_num = re.search(r'"([^"]+?.py)", line (\d+)', msg[-4]).groups()
        line_num = int(line_num)
        print(f'ðŸ˜ž Your code has {err} error on line {line_num} of {os.path.basename(filename)}')
        print(f'   {msg[-3]}\n   {msg[-2]}')
    elif msg[-1].startswith("EOFError"):
        print("ðŸ˜ž Your code has input() calls at the top level, all of your code must be in functions.")
    else:
        print("ðŸ˜ž Your code failed to import for an unknown reason.")
        print()
        print('\n'.join(msg))


class HelpfulTestResult(unittest.TestResult):
    """
    The TestResult collector object for helpful unittesting framework. Keeps track of a few extra
    things that the original TestResult doesn't.
    """
    def __init__(self):
        super().__init__()
        self.successes = []
        self.helpful_failures = []

    def addSuccess(self, test):
        super().addSuccess(test)
        self.successes.append(test)

    def addFailure(self, test, err):
        super().addFailure(test, err)
        _, value, _ = err
        # type should always be a subclass of AssertionError using the default setup
        self.helpful_failures.append((test, getattr(value, 'helpful_msg', self.failures[-1][1])))

    def addError(self, test, err):
        super().addError(test, err)
        if issubclass(err[0], ImportError):
            raise err[1] # just pass it up along to the test runner who will deal with it
        if issubclass(err[0], Timeout):
            msg = 'âŒ› Took too long to run, perhaps you have an infinite loop or an extra input() call?\n'
            traceback = _skip_unittest_frames(err[2])
            msg += _get_verbose_code_from_tb(traceback) + '\n'
            # TODO: make sure this stays in student's code
            while (traceback.tb_next is not None and
                   traceback.tb_next.tb_frame.f_code.co_filename != __file__):
                traceback = traceback.tb_next
            msg += _get_verbose_code_from_tb(traceback, 'The line of code running')
            self.errors[-1] = (test, msg)

class HelpfulTestRunner:
    """
    The Helpful Testing framework Test Runner - implements the single method run() that is required
    for Python's unittest module.
    """
    def run(self, testcase):
        """
        The main run() for the Helpful Testing Framework. Uses HelpfulTestResults to accumulate
        results and the timeout class to restrict the amount of time for any particular test.
        """
        result = HelpfulTestResult()
        #registerResult(result)

        # Run the tests
        with warnings.catch_warnings(), timeout(1):
            result.startTestRun()
            try:
                testcase(result)
            except ImportError as ex:
                _print_import_error(ex)
                return result
            finally:
                result.stopTestRun()

        if result.wasSuccessful():
            print("ðŸ™‚ All tests passed successfully!")
        else:
            print("ðŸ™ Your code did not pass all of the tests.")
        print()

        for msg, lst in (
                ('Succeeded: %d', result.successes),
                ('Skipped: %d (incomplete extra credit or alternate options)', result.skipped)
            ):
            if lst:
                print(msg % len(lst))
                for test in lst:
                    if isinstance(test, tuple): test = test[0]
                    print(f'  {HelpfulTestRunner.get_test_name(test)}')
                print()

        for msg, lst in (
                ("Failed: %d (your code didn't return/output the expected value)",
                 result.helpful_failures),
                ('Errored: %d (your code crashed during the test)', result.errors)
            ):
            if lst:
                print('='*75)
                print()
                print(msg % len(lst))
                print()
                for test, exc in lst:
                    print(f'  {HelpfulTestRunner.get_test_name(test)}:')
                    print('    ' + ("\n    ".join(exc.splitlines())))
                    
        return result

    @staticmethod
    def get_test_name(test):
        """
        Gets the name of a test including it's class, method, and any short description proviced.
        """
        # pylint: disable=protected-access
        name = f'{test.__class__.__name__}.{test._testMethodName}'
        desc = test.shortDescription()
        return f'{name}\n{desc}' if desc else name

def __has_doc(body):
    return isinstance(body[0], ast.Expr) and isinstance(body[0].value, ast.Str)

def check_module_structure(name, require_doc=False, forbid_useless_pass=False):
    """
    Makes sure that a module only contains a single string at the very beginning (for
    documentation), optional imports after that, optional assignment statements after that,
    function definitions, and then a single if at the very end.

    Optionally can also check that every function has documentation and that there are no pass
    statements directly inside functions that have other code.
    """
    filename = name + '.py' # TODO
    with open(filename) as file:
        root = ast.parse(file.read(), filename)
    body = root.body[:]
    # Documentation check
    if not __has_doc(body[0]):
        pass # TODO
    body.pop(0)
    # Import and assignment checks
    while body and isinstance(body[0], (ast.Import, ast.ImportFrom)):
        body.pop(0)
    while body and isinstance(body[0], ast.Assign):
        # TODO: body[0].value should only be simple types
        body.pop(0)
    # Function checks
    func_count = 0
    while body and isinstance(body[0], ast.FunctionDef):
        func_count += 1
        has_doc = __has_doc(body)
        if require_doc and not has_doc: pass # TODO
        if (forbid_useless_pass and len(body[0].body) > (2 if has_doc else 1) and
                any(isinstance(stmt, ast.Pass) for stmt in body[0].body)):
            pass # TODO
        body.pop(0)
    if func_count == 0:
        pass # TODO
    # Final if statment
    if not body:
        pass # TODO
    if len(body) > 1:
        pass # TODO
    if not isinstance(body[0], ast.If) or body[0].orelse is not None or len(body[0].body) != 1:
        pass # TODO
    test = body[0].test
    call = body[0].body[0]
    # TODO: left or comparators[0] must be a Name with .id == "__name__" with the other being a
    # Str with s == "__main__"
    if not isinstance(test, ast.Compare) or test.ops != [ast.Eq] or len(test.comparators) != 1:
        pass # TODO
    if not isinstance(call, ast.Expr) or not isinstance(call.value, ast.Call):
        pass # TODO

def __indent_lines(string, spaces):
    if string == '': return string
    spaces = ' '*spaces
    return spaces + ('\n'+spaces).join(string.splitlines())

def __indent_lines_maybe(string, spaces, no):
    return string if no else ('\n' + __indent_lines(string, spaces))

def __call_to_str(func, args=(), kwargs={}): # pylint: disable=dangerous-default-value
    sep = ', ' if args and kwargs else ''
    args = ', '.join(repr(arg) for arg in args)
    kwargs = ', '.join(key + '=' + repr(value) for key, value in kwargs.items())
    return f"{func.__module__}.{func.__qualname__}({args}{sep}{kwargs})"

def _helpful_failure(self, msg):
    ex = self.failureException(msg)
    ex.helpful_msg = msg
    return ex

def _raise_helpful_failure(self, msg):
    raise _helpful_failure(self, msg)

class redirect_stdin(contextlib._RedirectStream): # pylint: disable=protected-access, invalid-name
    """Equivalent to the contextlib.redirect_stdout() but for stdin."""
    _stream = 'stdin'

def _read_file(self, filename):
    dirname = os.path.dirname(sys.modules[self.__module__].__file__)
    with open(os.path.join(dirname, filename), 'r') as file:
        return file.read()

def _check_input(self, func, inpt, args=(), kwargs={}): # pylint: disable=dangerous-default-value
    msg = f"""The function call was: {__call_to_str(func, args, kwargs)}
The 'user' typed:\n{__indent_lines(inpt, 4)}\n"""

    # Prepare the simulated standard input and output
    # The input read() and readline() functions are wrapped so input also shows in the output
    out = io.StringIO()
    in_ = io.StringIO(inpt)
    inpt_ranges = [] # ranges in the output that are actually from the input
    def _read(*args, **kwargs):
        data = io.StringIO.read(in_, *args, **kwargs)
        inpt_ranges.append((len(out.getvalue()), len(data)))
        out.write(data)
        return data
    def _readline(*args, **kwargs):
        data = io.StringIO.readline(in_, *args, **kwargs)
        inpt_ranges.append((len(out.getvalue()), len(data)))
        out.write(data)
        return data
    in_.read = _read
    in_.readline = _readline

    # Call the function with the simulated stdin and stdout
    has_eof_err = False
    try:
        with contextlib.redirect_stdout(out), redirect_stdin(in_):
            retval = func(*args, **kwargs)
    except EOFError:
        has_eof_err = True

    # Check for EOF
    if has_eof_err:
        msg += 'You read all information given and then kept trying to get more input.'
        raise _helpful_failure(self, msg)

    # Check that all of the input was used
    if in_.tell() == 0:
        msg += 'You did not read any input at all.'
        raise _helpful_failure(self, msg)
    rem = in_.read()
    if rem:
        msg += 'Not all of that input was used, you stopped reading input once you got:\n'+(
            __indent_lines(inpt[:-len(rem)].rstrip('\n').split('\n')[-1], 4))
        raise _helpful_failure(self, msg)

    # Leave the rest to the assert function
    return msg, retval, out.getvalue().rstrip(), inpt_ranges

def __bold(string):
    """
    Bolds a string using unicode. Only letters and digits are supported. All
    other characters are passed through unchanged.
    """
    output = ''
    for ch in string:
        x = ord(ch)
        if 48 <= x <= 57: # numbers
            output += chr(x+120812-48)
        elif 65 <= x <= 90: # uppercase
            output += chr(x+120276-65)
        elif 97 <= x <= 122: # lowercase
            output += chr(x+120302-97)
        else:
            output += ch
    return output

def __bold_substr(string, start, end):
    """
    Applies bolding with __bold() to a substring, returning the complete string.
    """
    return string[:start] + __bold(string[start:end]) + string[end:]

def __strikethrough(text, charcode='\u0334'):
    """
    Uses unicode combining characters to strikethrough an entire string. By
    default this uses the ~ symbol instead of - to reduce confusion when placed
    over a space. To use -, the second argument should be '\u0336'.
    """
    return ''.join(charcode + ch for ch in text)

def __underline(text, charcode='\u0333'):
    """
    Uses unicode combining characters to underline an entire string. By default
    this uses a double underscore instead of _ to reduce confusion when placed
    over a space. To use _, the second argument should be '\u0332'.
    """
    return ''.join(charcode + ch for ch in text)

def __styling(ch, last_ch, marker, current, start, end):
    if ch == marker:
        return '' if current else start, True
    elif current and last_ch != marker:
        return ch + end, False
    else:
        return ch, current

def __convert_to_html(text):
    #with contextlib.redirect_stdout(output), contextlib.redirect_stdout(output):

    # Note that none of the modes (bold, underline, strikethrough) should be nested
    ch_map = {'\n': '<br>', '<': '&lt;', '>': '&gt;', '&': '&amp;', '"': '&quot;', "'": '&apos;'}
    ins_ = '<ins style="text-decoration:underline;background-color:#d4fcbc;">' 
    del_ = '<del style="text-decoration:line-through;background-color:#fbb;color:#555;">'
    b_ = '<b style="font-style:italic;font-weight:bolder;color:green;">'
    output = '<pre>'
    bolding = underlining = strikethrough = False
    last_ch = ''
    for raw_ch in text:
        ch = raw_ch
        if ch in ch_map:
            ch = ch_map[ch]
        else:
            # TODO: since only numbers and letters bold (and not spaces or symbols) we should not turn off bolding in certain cases...
            now_bolding = False
            x = ord(ch)
            if   120812 <= x < 120812+10: ch = chr(x-120812+48); now_bolding = True # numbers
            elif 120276 <= x < 120276+26: ch = chr(x-120276+65); now_bolding = True # uppercase
            elif 120302 <= x < 120302+26: ch = chr(x-120302+97); now_bolding = True # lowercase
            if bolding != now_bolding:
                ch = b_ + ch if now_bolding else ch + '</b>'
                bolding = now_bolding
        ch, underlining = __styling(ch, last_ch, '\u0333', underlining, ins_, '</ins>')
        ch, strikethrough = __styling(ch, last_ch, '\u0334', strikethrough, del_, '</del>')
        output += ch
        last_ch = raw_ch
    if bolding: output += '</b>'
    if underlining: output += '</ins>'
    if strikethrough: output += '</del>'
    output += '</pre>'
    return output

def __diff_line(a, b, limit=0.0):
    """
    Computes a line difference between the a and b strings (in theory they
    should be each a single line that is similar, but they can also be
    multiples lines each (using \n)).

    Returns a string with underlines where there should be insertions in a and
    strikethroughs for things that should be deleted from a.

    The third argument limit determines if a string should be analyzed or not.
    If not analyzed because too much of the line has been changed, then this
    will return None instead of the matching string. A value of 1.0 would make
    this always return None, a value of 0.0 makes this never return None.
    """
    out = ''
    matcher = difflib.SequenceMatcher(a=a, b=b)
    if limit > 0 and limit >= matcher.ratio():
        return None
    for tag, i1, i2, j1, j2 in matcher.get_opcodes():
        if tag =='equal':
            out += a[i1:i2]
        elif tag == 'delete':
            out += __strikethrough(a[i1:i2])
        elif tag == 'insert':
            out += __underline(b[j1:j2])
        elif tag == 'replace':
            out += __strikethrough(a[i1:i2])
            out += __underline(b[j1:j2])
    return out

def __diff_lines(a, b):
    """
    Computes the difference between the a and b list-of-strings with each string
    being one line. This finds equal sections of the lists and the parts that
    need editing are run through __diff_line individually.

    Returns a string with underlines where there should be insertions in a and
    strikethroughs for things that should be deleted from a. The returned result
    is a list of strings.
    """
    out = []
    matcher = difflib.SequenceMatcher(a=a, b=b)
    for tag, i1, i2, j1, j2 in matcher.get_opcodes():
        if tag =='equal':
            out.extend(a[i1:i2])
        elif tag == 'delete':
            out.extend(__strikethrough(a[i]) for i in range(i1, i2))
        elif tag == 'insert':
            out.extend(__underline(b[j]) for j in range(j1, j2))
        elif tag == 'replace':
            for a_line, b_line in zip(a[i1:i2], b[j1:j2]):
                if (diff := __diff_line(a_line, b_line, 0.5)) is None:
                    # TODO: group some of these lines together?
                    out.append(__strikethrough(a_line))
                    out.append(__underline(b_line))
                else:
                    out.append(diff)
            for i in range(i1 + j2-j1, i2): out.append(__strikethrough(a[i]))
            for j in range(j1 + i2-i1, j2): out.append(__underline(b[j]))
    return out

def _check_output(self, msg, printed, inpt_ranges, expected,
                  _whitespace='relaxed', _ordered=True, _regexp=False):
    printed_orig = printed
    # TODO: compare without input ranges or add input to expected
    #for start, length in inpt_ranges:
    #    printed = printed[:start] + printed[start+length:]
    expected_orig = expected
    if _whitespace == 'relaxed':
        printed = '\n'.join(line.rstrip() for line in printed_orig.rstrip('\n').split('\n'))
        expected = '\n'.join(line.rstrip() for line in expected.rstrip('\n').split('\n'))
    elif _whitespace == 'ignore':
        printed = ''.join(printed_orig.split())
        expected = ''.join(expected.split())
    elif _whitespace == 'strict':
        printed = printed_orig

    if not _ordered or not _regexp:
        printed = printed.split('\n')
        expected = expected.split('\n')

    if not _ordered:
        printed.sort()
        expected.sort()

    if not _regexp:
        mismatch = printed != expected
    elif isinstance(printed, list):
        mismatch = any(re.search(e, p) is None for e, p in zip(expected, printed))
    else:
        mismatch = re.search(expected, printed) is None
    if mismatch:
        single_line = '\n' not in expected_orig and '\n' not in printed_orig
        expected_note = actual_note = ''
        if _regexp:
            expected_note = ' (this is a regular-expression, so will likely look cryptic)'
        if inpt_ranges:
            for start, length in inpt_ranges:
                printed_orig = __bold_substr(printed_orig, start, start+length)
            actual_note = ' (green text is user entered)'
        msg += f'''Expected output{expected_note}: {__indent_lines_maybe(expected_orig, 4, single_line)}'''
        msg += f'''\nActual output{actual_note}: {__indent_lines_maybe(printed_orig, 4, single_line)}'''
        if not _regexp and _whitespace != 'ignore':
            # diffs not supported for whitespace='ignore' or _regexp
            # TODO: support whitespace='ignore'
            if single_line:
                diff = __diff_line(printed[0], expected[0])
            else:
                diff = '\n'.join(__diff_lines(printed, expected))
            msg += '\nDifference (\u0333  are things your output is missing, \u0334  are things your output has extra):\n'
            msg += __indent_lines(diff, 4)

        if _whitespace == 'ignore': msg += '\nNote: all whitespace is ignored'
        if not _ordered: msg += '\nNote: order of the lines does not matter'

        raise _helpful_failure(self, msg)

def _assertOutputEqual(self, expected, func, *args,
                       _whitespace='relaxed', _ordered=True, _regexp=False, **kwargs):
    """
    Assert that the output (written to stdout) equals the expected output. The function object must
    be passed in (not already called). If it takes arguments, they can be passed in the args and
    kwargs arguments.

    Optionally, the _whitespace keyword argument can be given to determine how whitespace is
    compared. It can be either 'strict' (whitespace must be exactly equal), 'relaxed' (the default,
    trailing whitespace on each line is ignored), or 'ignore' (all whitespace is ignored).

    The optional _ordered keyword can be given as False to cause the order of the lines to not
    matter when checking the output. This is not compatible with ignoring the whitespace.

    The optional _regexp keyword can be given as True to cause the `expected` argument to be
    treated as as a regular expression during matching.

    Not all combinations of keyword arguments will produce reasonable results. Specifically,
    when using _ordered=False with _regexp=True or _whitespace='ignore'.
    """
    msg = f"The function call was: {__call_to_str(func, args, kwargs)}\n"
    out = io.StringIO()
    with contextlib.redirect_stdout(out):
        func(*args, **kwargs)
    _check_output(self, msg, out.getvalue(), (), expected, _whitespace, _ordered, _regexp)

def _assertOutputEqualUsingUserInput(self, inpt, output, func, *args,
                                     _whitespace='relaxed', _ordered=True, _regexp=False, **kwargs):
    """
    Assert that the output (written to stdout) equals the expected output. The function object must
    be passed in (not already called). If it takes arguments, they can be passed in the args and
    kwargs arguments. Additionally, the function grabs user input (from stdin) and this is checked
    for as well. The input is given in the inpt argument and is added to the printed output.

    The optional _whitespace, _ordered, and _regexp keyword arguments are treated as per
    assertOutputEqual().
    """
    msg, _, out, inpt_ranges = _check_input(self, func, inpt, args, kwargs)
    _check_output(self, msg, out, inpt_ranges, output, _whitespace, _ordered, _regexp)

def _assertEqualUsingUserInput(self, inpt, expected, func, *args, _must_output_args=True, **kwargs):
    """
    Assert that the return value is equal when calling the function with the given arguments and
    keyword arguments along with providing the given input to stdin to be read in. It makes sure
    that all of the input is read. By default you also makes sure that provided arguments also
    show up in the output, but settings _must_output_args=False this will not be checked.
    """
    # Call the function and deal with input checks
    msg, retval, out, _ = _check_input(self, func, inpt, args, kwargs)

    # Check that the return value is correct
    if retval != expected:
        from ._testcase_assert_mod import __repr
        msg += f'Expected return value: {__repr(expected)}\nActual return value:   {__repr(retval)}'
        raise _helpful_failure(self, msg)

    # Check that all the pieces of text showed up in the output
    if _must_output_args:
        for arg in itertools.chain(args, kwargs.values()):
            if isinstance(arg, str):
                if arg not in out:
                    msg += f'The argument value "{arg}" was supposed to appear in the output.\n'
                    msg += f'The actual output was:\n{__indent_lines(out, 4)}'
                    raise _helpful_failure(self, msg)

@contextlib.contextmanager
def _assertNoPrint(self, print_func_okay=False, msg="You are not allowed to use print(), instead use return values"):
    """
    Context manager that raises an assert error if print() is called (with any file) or if
    sys.stdout is written to from any source. Used like:

    with self.assertNoPrint():
        pass # code to run that should never print() or write to stdout
    """
    orig_print = builtins.print
    output = io.StringIO()
    with contextlib.redirect_stdout(output):
        try:
            if not print_func_okay:
                builtins.print = lambda *args, **kwargs: _raise_helpful_failure(self, msg)
            yield None
        finally:
            builtins.print = orig_print
            if output.getvalue(): raise _helpful_failure(self, msg)

@contextlib.contextmanager
def _assertNoInput(self, msg="You are not allowed to use input(), instead use parameters"):
    """
    Context manager that raises an assert error if input() is called or if sys.stdin is read from
    by any source. Has the side effect that this will suppress any EOFError exceptions. Used like:

    with self.assertNoInput():
        pass # code to run that should never input() or read from stdin
    """
    orig_input = builtins.input
    with redirect_stdin(io.StringIO()):
        try:
            builtins.input = lambda prompt="": _raise_helpful_failure(self, msg)
            yield None
        except EOFError:
            raise _helpful_failure(self, msg)
        finally:
            builtins.input = orig_input

def _assertDoc(self, func, min_length=16):
    """
    Asserts that the given module of function has a docstring of at least the given length.
    """
    name = func.__name__ if isinstance(func, types.ModuleType) else f"{func.__name__}()"
    doc = getattr(func, '__doc__', None)
    if doc is None:
        raise _helpful_failure(self, f"No docstring provided for {name}")
    if len(doc.strip()) < min_length:
        raise _helpful_failure(self, f"Docstring for {name} isn't very descriptive...")

def add_test_case_special_asserts():
    """
    Adds several additional assert*() methods to the unittest.TestCase class:
      * assertDoc
      * assertOutputEqual
      * assertEqualUsingUserInput
      * assertOutputEqualUsingUserInput
      * assertNoPrint  (context manager)
      * assertNoInput  (context manager)
    And utility methods:
      * helpful_failure
      * read_file
    """
    unittest.TestCase.read_file = _read_file
    unittest.TestCase.helpful_failure = _helpful_failure
    unittest.TestCase.assertOutputEqual = _assertOutputEqual
    unittest.TestCase.assertEqualUsingUserInput = _assertEqualUsingUserInput
    unittest.TestCase.assertOutputEqualUsingUserInput = _assertOutputEqualUsingUserInput
    unittest.TestCase.assertNoPrint = _assertNoPrint
    unittest.TestCase.assertNoInput = _assertNoInput
    unittest.TestCase.assertDoc = _assertDoc

def main():
    # TODO: needs lots of work (arguments, return code, ...)
    wrap_test_case_asserts()
    add_test_case_special_asserts()

    # Discover the tests but also do some checks since they will be imported
    tc = unittest.TestCase()
    msg = "ðŸ¤ You are not allowed to use print() or input() at the top level, everything must be in functions"
    try:
        with warnings.catch_warnings(), timeout(1), _assertNoPrint(tc, msg=msg), _assertNoInput(tc, msg=msg):
            tests = unittest.defaultTestLoader.discover(os.getcwd(), '[!_]*.py')
    except ImportError as ex:
        _print_import_error(ex)
        return
    except AssertionError as ex:
        print(getattr(ex, 'helpful_msg', str(ex)))
        return
    except Timeout as ex:
        print('âŒ› Took too long to import, you shouldn\'t have any code not in functions\n')
        return

    # Assume these are fine
    instructor_tests = unittest.defaultTestLoader.discover(os.getcwd(), '_*.py')

    # Run the unittests
    HelpfulTestRunner().run(unittest.TestSuite((tests, instructor_tests)))


if __name__ == "__main__":
    main()
